### Create virtual env using
- python3 -m virtualenv venv env
- pip install -r requirements.txt
- docker-compose up -d -> to run mysql server

### Contains the code for MySql POC in python

- wait_timeout -> This is said to be the number of seconds the server waits for activity on a noninteractive connection before closing it.
- connect_timeout -> The number of seconds that the mysqld server waits to connect the packet before responding with a Bad handshake.
- sleep -> A sleeping MySQL query is an inactive open connection. When too many exist at the same time, the MySQL server will run out of connections,
            causing the server to be unable to process queries.

- Singleton connection
    - singleton.py
    - close() -> The Close method rolls back any pending transactions. When connection pooling is disabled it closes the connection to mysql server and can not be reused.
    - To check if required number of connections are made, go inside docker container and run mysql cli
        - docker exec -it mysql bash
        - mysql -u admin -p (admin123)
        - Run the command -> **show status where `variable_name` = 'Threads_connected';**
        - By default session wait timeout and interactive wait timeout is 28800 ( 8 hrs ), to check this -> **SELECT @@global.wait_timeout, @@session.wait_timeout;**
        - As soon as script finish running, the connections are closed. To overcome this and see number of connections made, have used for loop infinitely.
        - If script is running infinitely and we change wait time out to something smaller like 20 secs, connections will get closed after wait timeout.
        - We can change wait timeout globally like -> **SET GLOBAL wait_timeout = 20;** or session wise -> **SET SESSION wait_timeout = 20;**
- Connection pooling
    - pool.py
    - close() -> It puts back the connection into the pool and can be re-used.
- Relation between sleep, close and wait_timout ?
    - When we create any mysql connection, it remains open unitl wait_timeout. So if let's say wait_timout is 120 secs it will be open till 120 secs.
    - But if in mean time your connection is not performing any query, it will go into sleep state.
    - We can check that using **show full processlist;**
    - But let's say we want to close the connection, we can run close() method on connection object.
    - Again running **show full processlist;** will show connection one less.
    - To demonstrate this, see and run the code **python3 mysql_poc/singleton.py**. (I have used infinite loops so that connections do not close upon script finishing.)
    - In another terminal tab, open the docker mysql and run above commands.
- Connection re-using
    - connection_reusing.py
    - In connection reusing via pooling, we create a pool of 5 connections.
    - We spawn 5 different threads with different sleep and then closing their respective db connection.
    - Closing here means putting it back in the pool.
    - We close 1st thread connection after 10 sec and hence available to the pool after 10 secs
    - Now after 15 secs we spawn 6th thread and try to get a connection from the pool, we will get it as 1st thread has put the connection back to the pool.
    - So this way we can re-use connection from pool. Useful when we have high throughput application and want to avoid connection creation overhead.
    - Try to play with it by reducing and increasing sleep (close) and also to immediately get the 6th connection without sleep.
    - Observe different kind of pool errors.
- What happens with mysql connection when code breaks in between
    - If application is still up like a web server running then connection will be there in memory else will be lost.
- Multiple threads sharing same mysql connection object and executing query on same connection.
    - singleton_threaded.py
    - In this file we have two function, with_thread and with_thread_sequential
    - When we run with_thread function, both the threads execute query in paraller on same connection, but result in memory related errors and hence we can not run two queries in parallel on same connection.
    - But when we run with_thread_sequential, it runs succesfully, since those threads are running queries one after the other ( not parallel ).
    - It might also be internal library specific implementation, that we are observing this behaviour, although it might change for some other languages and libraries.
    - Try running and playing with those functions.
- Transaction Isolation Levels
- Types of joins mysql support
- Types of Indexing..
- Common query optimizations..
- MySql important config vars ( connection related )
- Optmizations of config vars
- Various types of aggregations mysql support
- Stored Procedures
- Triggers
- Case study of payment systems -> Make sure that payment is done correctly without race condition if there are multiple transactions going on for payment.
- Master-Slave architecture
- Log replication ( and its types i.e row based and statement based ) and syncing between master-slave
- Data Partition
- Sharding
- Connection loading and checking memory
- Data types mysql support ..
- Common data structure mysql uses ..
